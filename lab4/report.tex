\include{settings}

\begin{document}

\include{titlepage}

\section{Задание}
    Транслятор операторов $while$ языка $C$:
    
    Тип данных: int.
    
    Условное выражение: арифметическое бесскобочнрое выражение,
    т.е. операции выполняются слева на право.

    В теле цикла:
    \begin{enumerate}
        \item операторы присваивания вида $id=$ бесскобочное арифметическое выражение
        \item вложенный оператор $while$
    \end{enumerate}

    Выходной продукт:
    \begin{enumerate}
        \item текст на языке ассембера A86
        \item тетрады матрицы синтаксического дерева
    \end{enumerate}

\section{Ход работы}
    Задание выданое преподавателем было изучено и рассмотрено с точки зрения реализуемости.\\
    
    Было решено:
    \begin{itemize}
        \item   Использовать язык ассемблера для архитектуры x86. 
                В связи с тем, что эта архитектура наиболее распространена 
                и был найден удобный транслятор из языка С в язык ассембера x86.
                (\href{https://gcc.godbolt.org/}{https://gcc.godbolt.org/})

        \item   Использовать только одну переменную. Это решение было принято
                в связи с тем, что при использовании нескольких переменных,
                помимо выявления этих переменных необходимо было бы их различать,
                что повлекло бы за собой необходимость самописной структуры данных.
                К этой структуре появляются требования, такие как расширяемость.
                Что влечёт достаточно большой объем кода, который никак не связан
                с языками $lex$ и $yacc$. Учитывая указанную проблему, было решено отказаться
                от использования нескольких переменных, но со стороны части программы, которая
                отвечает за синтаксический и лексический разбор, обеспечить необходимую функциональность для
                возможности дальнейшней работы с ними.

        \item   Отказаться от использования операций типа:
        
                int a, b, c, d;

                a = b + c + 1 + d;

                Подобное решение было связано с тем, что операции, состоящие из
                нескольких переменных, во первых были невозможны из-за предыдущего пункта
                этого списка, а во вторых из-за того что после трансляции они генерируют
                достаточно сложный текст. 

                \begin{figure}[h]
                    \center{\includegraphics[scale=0.5]{img/1.png}}
                    \label{fig:image}
                \end{figure}
        
        \item   Также было решено отакзаться от вложенных циклов, в связи с тем, что
                основная сложность подобных конструкций это генерация меток, что
                не является интересной задачей, и слабо относится к языкам синтаксического и
                лексического разбора.

    \end{itemize} 

    Учитывая все перечисленные требования и нюансы была разработана программа:

    \lstinputlisting {src/c.l}
    \lstinputlisting {src/c1.y}
    \lstinputlisting {src/zz.c}

    В качестве входных данных было подано следующее:
    \lstinputlisting {src/test.in}

    В результате работы программы получили следующее:
    \lstinputlisting {src/test.out}

    Что соответствует результатам трансляции с помощью сторонней программы:
    \begin{figure}[h]
        \center{\includegraphics[scale=0.5]{img/2.png}}
        \label{fig:image}
    \end{figure}

    Следовательно, можно считать, что разработаная программа работает верно.

\section{Возможные улучшения}
    Как в случае с использованием нескольких переменных,
    так и в случае вложенных циклов $while$,
    чтобы обеспечить их поддержку необходимо  преодолеть ряд трудностей,
    которые свзяаны не с лексическим или синтаксическим разбором, а именно
    с генерацией кода на языке ассембера.
    
    В случае с вложенными циклами нужны уникальные
    значения для меток, по которым переходит программа
    во время итерации. В той реализации,
    которая предложена на данный момент метки называются одинаково.
    Что касается лексической и синтаксической обработки данных ситуаций,
    то с их стороны всё реализовано.
    
    В случае с переменными необходимо определять,
    наличие или отсутствие объявления перменной указанной в выражении -
    это можно реализовать с помощью структуры данных, которая хранит в однозначном
    соответствии имя переменной и место в памяти, где расположено
    значение.
    Причём, структура должна быть расширяющейся, так как
    мы не можем заранее предсказать сколько переменных планирует
    использовать программист.
    В этом случае проблема отсутствия реализации в итоговой программе
    заключается в том, что подобная функциональность влечёт большой
    объем кода на языке С, слабо относящийся к языкам $lex$ и $yacc$,
    изучение и работа с которыми ставятся в главные цели лабораторной работы.


\section{Вывод}
    В результате выполнения лабораторной работы был написан простейший 
    транслятор операторов $while$ языка $C$. Для написания программы
    использовались генераторы синтаксического и лексического разбора
    $yacc$ и $lex$. В ходе выполнения работы сначала было определено
    какую функциональность будет включать конечное приложение. Далее
    был разработана часть отвечающая за лексический разбор, в след за
    ней была написана часть, в задачи которой входит синтаксический разбор.
    Получившаяся программа была протестирована на различных входных данных.
    Полученные результаты соответствует тому, что было описано в задании.

    Проведенная работа позволила лучше понять принципы совместного
    использования генерторов для синтаксического и лексического разбора и
    принципы посторения трансляторов для языков программирования.
    Также в ходе выполнения лабораторной были получены навыки разработки
    приложений на основе этих языков. 


\section{Используемая литература}
    \begin{itemize}
        \item John Levine. Flex \& Bison: Text Processing Tools. — O\'{}Reilly Media, 2009
        \item Программирование лексического и синтаксического разбора на языках C, Lex и Yacc — А.В. Жуков, 2014
    \end{itemize}

\end{document}
