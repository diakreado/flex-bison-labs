\include{settings}

\begin{document}

\include{titlepage}

\section{Цель работы}
\begin{itemize}
\item Познакомиться с языком синтаксического разбора $yacc$
\item Выполнить трансляцию предложенных программ на языке $yacc$. Протестировать их работу.
\end{itemize}


\section{Ход работы}

\subsection{Проверка формата даты}

    Рассмотрим программу, на языках $lex$ и $yacc$,
    которая проверяет корректность введенной даты:
    \lstinputlisting {src/_date/v1/v1.y}
    \lstinputlisting {src/_date/v1/v1.l}

    Сгенерированный файл:
    \lstinputlisting {src/_date/v1/zz.c}

    Проверим корректность работы программы.
    Для этого подадим на вход следующие тестовые данные:
    \lstinputlisting {src/_date/v1/test.in}

    Программа отработала корректно. 
    Так как ошибок обнаружено не было,
    то вывод программы тоже оказался пустым.

    Входные данные были модифицированы, с целью получить сообщение об ошибке:
    \lstinputlisting {src/_date/v1/test1.in}

    В итоге, в консоль было выведено сообщение $?-syntax error$.
    Что сведетельствует, о несоответствии входных данных
    разработаному шаблону формата даты.
    Программа обнаружила несоответствие формату в предложенных,
    заведомо некорректных, данных, следовательно, можно считать, что программа
    работает правильно. 

\subsection{Изменение структуры ввода даты}
    
    Модифицируем программу из предыдущего пункта. Изменим формат даты, так чтобы между числами
    должна была бы идти запятая:
    \lstinputlisting {src/_date/v2/v2.y}
    \lstinputlisting {src/_date/v2/v2.l}

    Протестируем программу, в одном случае получив информацию,
    о корректном завершении, в другом об ошибке.

    Входные данные, которые привели к успешному завершению:
    \lstinputlisting {src/_date/v2/test.in}

    Входные данные, которые привели к ошибке:
    \lstinputlisting {src/_date/v2/test1.in}


\subsection{Доступ к семантическим значениям}

    Доступ к семантическим значениям осуществляется через псевдопеременные \$n.
    Рассмотрим следующую программу:
    \lstinputlisting {src/_date/v3/a/v3a.y}
    \lstinputlisting {src/_date/v3/a/v3.l}

    На вход программы было подано:
    \lstinputlisting {src/_date/v3/a/test1.in}

    В итоге получили:
    \lstinputlisting {src/_date/v3/a/test1.out}

    Следовательно можно сделать вывод, что программа отработала корректно.


\subsection{Проверка даты и вывод количества дней от 1970 г.}

    Рассмотрим программу, которая выводит количество дней от 1970-01-01,
    а также проверяет корректность введенной даты:
    \lstinputlisting {src/_date/v3/b/v3b.y}
    \lstinputlisting {src/_date/v3/b/v3.l}
    \lstinputlisting {src/_date/v3/b/abs_date.c}

    На вход программы было подано:
    \lstinputlisting {src/_date/v3/b/test.in}

    В итоге получили:
    \lstinputlisting {src/_date/v3/b/test.out}

    Следовательно можно сделать вывод, что программа отработала корректно.


\subsection{Семантическое значение date и вычисление разницы между датами}

    В приведенной ниже программе вычисляется разница между двумя введенными датами,
    а также проверяется их соответствие с заданым форматом:
    \lstinputlisting {src/_date/v3/d/v3c.y}
    \lstinputlisting {src/_date/v3/d/v3.l}
    \lstinputlisting {src/_date/v3/d/abs_date.c}

    На вход программы было подано:
    \lstinputlisting {src/_date/v3/d/test.in}

    В итоге получили:
    \lstinputlisting {src/_date/v3/d/test.out}

    Следовательно можно сделать вывод, что программа отработала корректно.

\subsection{Определение сопутствующего типа значения нескольких типов}

    Рассмотрим работу с двумя типами сопутствующих значений.
    Для этого модифицируем предыдущую программу:
    \lstinputlisting {src/_date/v5/v5.y}
    \lstinputlisting {src/_date/v5/v5.l}

    На вход программы было подано:
    \lstinputlisting {src/_date/v5/test.in}

    В итоге получили:
    \lstinputlisting {src/_date/v5/test.out}

    Следовательно можно сделать вывод, что программа отработала корректно.


\subsection{Рекурсивные правила}

    Рассмотрим программу разбирающую список чисел, разделенных запятыми:
    \lstinputlisting {src/list/v0/c1.y}
    \lstinputlisting {src/list/v0/c1.l}

    На вход программы было подано:
    \lstinputlisting {src/list/v0/test.in}

    В итоге получили:
    \lstinputlisting {src/list/v0/test.out}

    Следовательно можно сделать вывод, что программа отработала корректно.


\subsection{Использование рекурсии при чтении списка}

    Рассмотрим программу для чтения списка с помощью рекурсии:
    \lstinputlisting {src/list/v1/c1.y}
    \lstinputlisting {src/list/v1/c.l}

    На вход программы было подано:
    \lstinputlisting {src/list/v1/test.in}

    В итоге получили:
    \lstinputlisting {src/list/v1/test.out}

    Следовательно можно сделать вывод, что программа отработала корректно.


\subsection{Дополнительное микрозадание}

    \textbf{Микрозадание:}
    В списке могут быть целые числа со знаком и без знака.
    Основной разделитель чисел - запятая,
    но после запятой допускается произвольное количество пробелов.

    Подсчитать для каждой строки общее количество чисел
    и количество отрицательных чисел.

    Текст разработанной программы:
    \lstinputlisting {src/individual/c1.y}
    \lstinputlisting {src/individual/c.l}

    Входные данные:
    \lstinputlisting {src/individual/test.in}

    Выходные данные:
    \lstinputlisting {src/individual/test.out}

    Программа отработала корректно.


\section{Вывод}

    В результате выполнения работы были получены навыки работы с
    генератором программ синтаксической обработки текстов $yacc$
    и закреплены навыки работы с генератором программ лексической обработки текстов $lex$.
    Было изучено и запущено восемь программ,
    тексты которых были распространенны преподавателем.
    Также была разработана собственная программа,
    в соответствии с индивидуальным заданием.
    Программы были транслированы в текста на языке С,
    скомпилированы и запущены с различными входными данными.
    Эксперименты, которые наиболее полно
    отражают суть работы программы, приведены в отчёте.
    Проведенная работа позволила изучить проблемы, возникающие при разработке и шаблоны,
    которые могу служить решением для них.

\end{document}
